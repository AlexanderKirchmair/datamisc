

### Basic utils ------


#' Return the first n rows and columns of an object
#'
#' @param data
#' @param nrows
#' @param ncols
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
head2 <- function(data, nrows = 15, ncols = 10, ...){
  rows <- ifelse(nrow(data) < nrows, nrow(data), nrows)
  columns <- ifelse(ncol(data) < ncols, ncol(data), ncols)
  data[1:rows, 1:columns, drop = FALSE]
}


#' Limit number of characters in a string
#'
#' @param x character string
#' @param maxchar max. number of characters
#' @param add string added to truncated objects
#' @param add_incl include added string in maxchar
#'
#' @return
#' @export
#'
#' @examples
cutstr <- function(x, maxchar = 25, add = "...", add_incl = TRUE){
  ix <- nchar(x) > maxchar
  x[ix] <- substr(x[ix], 1, ifelse(add_incl, maxchar - nchar(add), maxchar))
  x[ix] <- paste0(x[ix], add)
  return(x)
}


#' File extension of path
#'
#' @param path
#'
#' @export
#'
#' @examples
#' baseext(list.files())
#'
baseext <- function(path, ...){
  path <- basename(path)
  ext <- gsub(x = path, pattern = ".*\\.", replacement = "")
  ext[!grepl(pattern = ".", x = path, fixed = TRUE)] <- NA
  ext
}


#' Memory size of workspace objects
#'
#' @param x
#' @param units
#'
#' @return
#' @export
#'
#' @examples size(ls())
size <- function(x, units = NULL){

  if (is.character(x)) x <- lapply(x, get)

  s <- object.size(x)
  o <- log10(s)

  if (is.null(units)){
    if (o > 2) units <- "Kb"
    if (o > 5) units <- "Mb"
    if (o > 8) units <- "Gb"
  }

  format(s, units = units)
}


#' Get class of a quoted object
#'
#' @param x
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
quo_class <- function(x, ...){
  x_class <- NA
  try({x_class <- class(rlang::eval_tidy(x, ...))}, silent = TRUE)
  x_class
}




### NA handling ------

#' Set NA values to FALSE
#' @return
#' @export
naf <- function(data, ...){
  data[is.na(data)] <- FALSE
  data
}


#' Set NA values to TRUE
#' @return
#' @export
nat <- function(data, ...){
  data[is.na(data)] <- TRUE
  data
}


#' Skip rows/columns containing NA values
#'
#' Function for fast subsetting of data (see also 'na.omit()').
#'
#'
#' @param data Dataset
#' @param skip Skip rows (columns) containing NA values.
#'
#' @return
#' @export
naSkip <- function(data, skip = "rows"){
  if (tolower(skip) %in% c("row", "rows")) i <- 1
  else if (tolower(skip) %in% c("col", "cols", "columns")) i <- 2
  else stop("Error: skip must be 'rows' or 'columns'.")

  ix <- !apply(is.na(data), i, any)

  if (i == 1) data <- data[ix,,drop = FALSE] else data <- data[,ix,drop = FALSE]

  data
}




### Random data generation ------


#' Generate a matrix of random numbers
#'
#' @description
#' Returns a matrix of size nrow x ncol from random numbers generated by FUN.
#'
#' @param nrow number of rows
#' @param ncol number of columns
#' @param FUN random number generator
#' @param ... parameters other than n passed to FUN
#'
#' @return
#' @export
#'
#' @examples
#' @seealso \code{\link[stats]{runif}}, \code{\link[stats]{rnorm}}, \code{\link[stats]{rexp}}
rmat <- function(nrow = 3, ncol = 5, FUN = runif, ...){
  n <- nrow * ncol
  v <- FUN(n = n, ...)
  matrix(data = v, nrow = nrow, ncol = ncol,
         dimnames = list(paste0("r", 1:nrow), paste0("c", 1:ncol)))
}


#' Generate a random list
#'
#' @param length length of the list
#' @param items (variable) number of items per list entry
#' @param space set of items to sample
#'
#' @return list
#' @export
#'
#' @examples
#' rlist()
#' rlist(length = 3, items = 2:4, space = 1:10)
rlist <- function(length = 5, items = 1:3, space = LETTERS){
  if (length(space) < max(items)) stop("Error: Requested number of items cannot exceed number of items in space!")
  res <- lapply(1:length, function(x) sample(space, size = sample(c(items, items), size = 1)) )
  setNames(res, paste0(seq(res), "_", sapply(res, function(x) paste0(x, collapse = "") ) ))
}




### Duplicate data manipulation ------


#' Get unique sets (irrespective of item order)
#'
#' @param sets list of sets
#' @param sep collapse set names
#'
#' @return
#' @export
#'
#' @examples
uniqueSets <- function(sets, sep = "&"){

  nonames <- is.null(names(sets))
  if (nonames) names(sets) <- seq(sets)

  which_dups <- sapply(sets, function(tmp1) sapply(sets, function(tmp2) {setequal(tmp1, tmp2) } ))
  diag(which_dups) <- FALSE

  dup_names <- sapply(colnames(which_dups), function(tmp1) rownames(which_dups)[which_dups[,tmp1]] )
  dedup_names <- sapply(names(dup_names), function(tmp){
    if (length(dup_names[[tmp]]) > 1){
      paste(sort(c(tmp, dup_names[[tmp]])), collapse = sep)
    } else {
      tmp
    }
  })

  names(sets) <- dedup_names
  sets <- sets[unique(dedup_names)]

  if (nonames) sets <- setNames(sets, NULL)
  sets <- lapply(sets, sort)
  return(sets)
}


#' Rename duplicated strings
#'
#' @param x character vector
#' @param sep separator
#' @param index indices added to duplicated elements
#' @param ... arguments passed to 'duplicated'
#'
#' @return
#' @export
#'
#' @examples
#' replicate(3, paste(LETTERS[1:3], collapse = "")) %>% dedupl()
#' replicate(3, paste(LETTERS[1:3], collapse = "")) %>% dedupl(sep = "_", index = letters)
#'
dedupl <- function(x, sep = ".", index = NULL, ...){

  xorg <- x
  ix <- duplicated(x, ... = )
  i <- 1

  if (is.null(index)){
    while (any(ix)){
      x[ix] <- paste0(xorg[ix], sep, i)
      ix <- duplicated(x, ...)
      i <- i + 1
    }
  } else {
    while (any(ix)){
      x[ix] <- paste0(xorg[ix], sep, index[i])
      ix <- duplicated(x, ...)
      i <- i + 1
    }
  }

  stopifnot(!any(duplicated(x, ...)))
  x
}




### Numeric data manipulations ------


#' Scale rows (columns) of a matrix
#'
#' @description
#' Apply FUN ('scale' by default) to the rows or columns of a numeric matrix.
#'
#' @param data Matrix or data.frame
#' @param rows Scale rows (TRUE/FALSE)
#' @param cols Scale columns (TRUE/FALSE)
#' @param FUN Function used for scaling
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
#' matScale(rmat(5, 5), rows = TRUE)
matScale <- function(data, rows = FALSE, cols = FALSE, FUN = scale, ...){

  data.org <- data
  ix <- sapply(as.data.frame(data), is.numeric)
  data <- data[,ix, drop = FALSE]
  names.org <- dimnames(data)

  if (rows == TRUE & cols == TRUE) stop("Error: Do not scale rows and columns at once!")

  if (rows == TRUE){
    data <- t(apply(data, 1, function(tmp) as.numeric(FUN(tmp, ...))))
  }

  if (cols == TRUE){
    data <- apply(data, 2, function(tmp) as.numeric(FUN(tmp, ...)))
  }

  dimnames(data) <- names.org
  data <- cbind(data, data.org[,!ix, drop = FALSE])
  if (!is.null(colnames(data.org))) data <- data[,colnames(data.org)]

  stopifnot( all.equal(dim(data.org), dim(data)) )
  return(data)
}


#' Replace Inf values for plotting
#'
#' @param data
#' @param increase
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
subInf <- function(data, increase = 0.2, ...){

  data.noinf <- data
  data.noinf[is.infinite(data)] <- NA
  maxval <- roundup(max(abs(data.noinf), na.rm = TRUE)*increase)

  data[data == Inf] <- maxval
  if (any(data < 0, na.rm = TRUE)) data[data == -Inf] <- -maxval

  data
}


#' Rounding of numbers
#'
#' @description
#' Round up
#'
#' @param x numeric vector
#' @param digits number of decimal places
#' @param ... other arguments passed to ceiling/floor
#'
#' @export
#'
roundup <- function(x, digits = 0, ...){
  ceiling(x * 10^digits, ...) / 10^digits
}


#' Rounding of numbers
#'
#' @description
#' Round down
#'
#' @inheritParam
#'
#' @export
#'
rounddown <- function(x, digits = 0, ...){
  floor(x * 10^digits, ...) / 10^digits
}




#' Adjust P-values for Multiple Comparisons
#'
#' @description
#' Adjust a vector or matrix of p-values derived from the same data for multiple testing.
#'
#' @param p vector or matrix of p-values
#' @param ...
#'
#' @inheritParam stats::p.adjust
#'
#' @return
#' @export
#'
padjust <- function(p, method = p.adjust.methods, ...){
  porig <- p
  is.mat <- !is.null(dim(porig))
  if (is.mat) p <- as.vector(data.matrix(p))
  padj <- stats::p.adjust(p, method = method, ...)
  if (is.mat) padj <- matrix(padj, nrow = nrow(porig), dimnames = dimnames(porig))
  if ("data.frame" %in% class(porig)) padj <- as.data.frame(padj)
  padj
}



### Dataframe processing ------


#' Cbind multiple matrices by shared rownames
#'
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
cjoin <- function(...){

  quos_args <- rlang::quos(...)
  dfnames <- sapply(quos_args, rlang::quo_name)

  dfnames1 <- names(list(...))
  if(!is.null(dfnames1)) dfnames[nchar(dfnames1)>0] <- dfnames1[nchar(dfnames1)>0]

  dflist <- lapply(quos_args, rlang::eval_tidy)
  dfs <- lapply(dflist, as.data.frame)

  for (i in which(sapply(dfs, ncol) == 1)){ colnames(dfs[[i]]) <- dfnames[i] }

  allids <- lapply(dfs, rownames)
  ids <- Reduce(f = intersect, x = allids)

  cols <- unlist(lapply(dfs, colnames))
  if (any(duplicated(cols))) cols <- paste0(cols, ".", rep(dfnames, sapply(dfs, ncol)))

  subdfs <- lapply(dfs, function(tmp) tmp[ids,,drop = FALSE] )
  res <- Reduce(f = cbind, x = subdfs)
  colnames(res) <- cols
  res
}


#' Rbind multiple matrices by shared colnames
#'
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
rjoin <- function(...){

  quos_args <- rlang::quos(...)
  dfnames <- sapply(quos_args, rlang::quo_name)

  dfnames1 <- names(list(...))
  if(!is.null(dfnames1)) dfnames[nchar(dfnames1)>0] <- dfnames1[nchar(dfnames1)>0]

  dflist <- lapply(quos_args, rlang::eval_tidy)
  dfs <- lapply(dflist, as.data.frame)

  for (i in which(sapply(dfs, ncol) == 1)){ colnames(dfs[[i]]) <- dfnames[i] }
  for (i in which(sapply(dfs, ncol) == 1)){ dfs[[i]] <- t(dfs[[i]]) }

  allids <- lapply(dfs, colnames)
  ids <- Reduce(f = intersect, x = allids)

  rows <- unlist(lapply(dfs, rownames))
  if (any(duplicated(rows))) rows <- paste0(rows, ".", rep(dfnames, sapply(dfs, nrow)))

  subdfs <- lapply(dfs, function(tmp) tmp[,ids,drop = FALSE] )
  res <- Reduce(f = rbind, x = subdfs)
  rownames(res) <- rows
  res
}


#' Write dataframes to .xlsx file
#'
#' @description
#' Write a dataframe or a named list of dataframes to a .xlsx file
#'
#' @param data
#' @param filename
#' @param adjwidths
#'
#' @export
#'
#' @seealso openxlsx::writeData
#' @examples
#' writeTables(mtcars, file = "example.xlsx")
#' writeTables(list(mtcars = mtcars, iris = iris), file = "example.xlsx")
#'
writeTables <- function(data, file, rowNames = TRUE, adjwidths = TRUE, ...){

  if (!"list" %in% class(data)){
    data <- setNames(list(data), gsub("\\..*$", "", basename(file)))
  }

  newnames <- cutstr(names(data), maxchar = 29)
  if (any(duplicated(newnames))){
    newnames <- cutstr(names(data), maxchar = 26)
    newnames <- dedupl(newnames)
  }
  names(data) <- newnames

  wb <- openxlsx::createWorkbook()

  invisible(lapply(names(data), function(tmpname){
    tmpdata <- data[[tmpname]]
    openxlsx::addWorksheet(wb, tmpname)
    openxlsx::writeData(wb, sheet = tmpname, x = tmpdata, rowNames = rowNames, ...)
    if (adjwidths == TRUE){
      openxlsx::setColWidths(wb, sheet = tmpname, cols = 1:(ncol(tmpdata)+1), widths = "auto")
    }
  }))

  if (baseext(file) != "xlsx") file <- paste0(file, ".xlsx")
  openxlsx::saveWorkbook(wb, file = file, overwrite = TRUE)
}


#' Read all sheets from .xlsx file
#'
#' @param file
#' @param rowNames
#' @param ...
#'
#' @export
#'
#' @examples
#' writeTables(list(mtcars = mtcars, iris = iris), file = "example.xlsx")
#' readTables(file = "example.xlsx")
readTables <- function(file, rowNames = TRUE, ...){
  sheets <- openxlsx::getSheetNames(file)
  res <- lapply(setNames(sheets, sheets), function(tmp) openxlsx::read.xlsx(sheet = tmp, xlsxFile = file, rowNames = rowNames, ...) )
  if (length(res) == 1) res <- res[[1]]
  res
}




















### Data processing ------



#' Hierarchical clustering of data
#'
#' @param data matrix or dataframe
#' @param method hclust
#' @param rows cluster rows
#' @param cols cluster columns
#' @param inf handling of non-finite values
#' @param na handling of missing values
#' @param ...
#'
#' @return clust
#' @export
#'
#' @examples
clusterData <- function(data, method = "hclust", rows = NULL, cols = NULL, inf = NULL, na = NULL, ...){

  ### Cluster rows/columns of a dataframe or matrix with NA or Inf values


  # input arguments
  if (is.null(rows)) rows <- nrow(data) < 1000
  if (is.null(cols)) cols <- ncol(data) < 1000
  if (is.null( na))  na <- ""
  if (is.null(inf)) inf <- ""



  # +/-Inf value handling
  if (any(!is.finite(nat(data)))){

    if (naf(inf == FALSE)) data <- subInf(data)
    if (is.na(inf)) data[!is.finite(data)] <- inf

  }



  # NA value handling (1)
  if (any(is.na(data))){


    if (is.numeric(na)) data[is.na(data)] <- na



  }







  # Clustering
  tmp <- list(rows = data, cols = t(data))
  res <- lapply(tmp[c(rows, cols)], function(data){

    # NA value handling (2)
    if (na == "omit") data <- na.omit(data)

    clust <- NULL

    if (method == "hclust") clust <- dendsort::dendsort(stats::hclust(stats::dist(data)))







    clust
  })



  # col.clusters <- dendextend::rotate(col.clusters, cluster_order)

  res
}






